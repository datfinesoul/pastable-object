// Generated by CoffeeScript 1.11.1
(function() {
  "use strict";
  var _, exports, fixedColumns,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  _ = require('lodash');

  fixedColumns = (function(_this) {
    return function(data, fields, headers, delimiter) {
      var alias, i, j, k, key, l, len, len1, len2, len3, m, metadata, order, orderIndex, remove, result, row, v, value;
      if (fields == null) {
        fields = [];
      }
      if (headers == null) {
        headers = [];
      }
      if (delimiter == null) {
        delimiter = ' ';
      }
      order = fields.slice(0);
      alias = headers.slice(0);
      if (!_.isEmpty(alias) && order.length !== alias.length) {
        console.log('hello');
        metadata = _.reduce(order, function(r, v, i) {
          r[v] = {
            index: i,
            alias: order[i]
          };
          return r;
        }, {});
        alias = [];
      }
      if (metadata == null) {
        metadata = {};
      }
      result = [];
      for (j = 0, len = data.length; j < len; j++) {
        row = data[j];
        for (key in row) {
          value = row[key];
          orderIndex = _.isEmpty(fields) ? Object.keys(metadata).length : _.findIndex(order, function(v) {
            return v === key;
          });
          if (orderIndex === -1) {
            continue;
          }
          if (metadata[key] == null) {
            metadata[key] = {
              index: orderIndex,
              alias: key
            };
          }
          if (indexOf.call(order, key) < 0 && _.isEmpty(fields)) {
            order.push(key);
          }
          metadata[key].type = typeof value;
          switch (metadata[key].type) {
            case 'string':
              metadata[key].max = _.max([0, metadata[key].max, value.length]);
              break;
            case 'number':
              metadata[key].max = _.max([0, metadata[key].max, value.toString().length]);
              break;
            default:
              metadata[key].max = 0;
          }
        }
      }
      if (_.isEmpty(alias)) {
        alias = order.slice(0);
      }
      remove = [];
      for (key in metadata) {
        value = metadata[key];
        if ((_.isEmpty(fields) || indexOf.call(fields, key) >= 0) && value.max) {
          value.max = _.max([value.max, alias[value.index].length]);
          switch (value.type) {
            case 'string':
              alias[value.index] = _.padEnd(alias[value.index], value.max, ' ');
              break;
            case 'number':
              alias[value.index] = _.padStart(alias[value.index], value.max, ' ');
          }
        } else {
          remove.push(value.index);
        }
      }
      remove.sort().reverse();
      for (k = 0, len1 = remove.length; k < len1; k++) {
        i = remove[k];
        order.splice(i, 1);
        alias.splice(i, 1);
      }
      remove = [];
      for (i = l = 0, len2 = order.length; l < len2; i = ++l) {
        v = order[i];
        if (!(v in metadata)) {
          remove.push(i);
        }
      }
      remove.sort().reverse();
      for (m = 0, len3 = remove.length; m < len3; m++) {
        i = remove[m];
        order.splice(i, 1);
        alias.splice(i, 1);
      }
      return result = _(data).chain().map(function(row) {
        var len4, n;
        result = [];
        for (n = 0, len4 = order.length; n < len4; n++) {
          key = order[n];
          switch (metadata[key].type) {
            case 'string':
              result.push(_.padEnd(row[key], metadata[key].max, ' '));
              break;
            case 'number':
              result.push(_.padStart(row[key], metadata[key].max, ' '));
          }
        }
        return result.join(delimiter);
      }).tap(function(rows) {
        return rows.unshift(alias.join(delimiter));
      }).join('\n').value();
    };
  })(this);

  module.exports = exports = {
    fixedColumns: fixedColumns
  };

}).call(this);
